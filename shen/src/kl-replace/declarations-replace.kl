"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(set shen.*installing-kl* false)

(set shen.*history* ())

(set shen.*tc* false)

(set *property-vector* (dict 20000))

(set shen.*process-counter* 0)

(set shen.*varcounter* (vector 1000))

(set shen.*prologvectors* (vector 1000))

(set shen.*demodulation-function* (lambda X X))

(set shen.*macroreg* (cons shen.timer-macro (cons shen.cases-macro (cons shen.abs-macro (cons shen.put/get-macro (cons shen.compile-macro (cons shen.datatype-macro (cons shen.let-macro (cons shen.assoc-macro (cons shen.make-string-macro (cons shen.output-macro (cons shen.input-macro (cons shen.error-macro (cons shen.prolog-macro (cons shen.synonyms-macro (cons shen.nl-macro (cons shen.@s-macro (cons shen.defprolog-macro (cons shen.function-macro ())))))))))))))))))))

(set *macros* (cons (lambda X (shen.timer-macro X)) (cons (lambda X (shen.cases-macro X)) (cons (lambda X (shen.abs-macro X)) (cons (lambda X (shen.put/get-macro X)) (cons (lambda X (shen.compile-macro X)) (cons (lambda X (shen.datatype-macro X)) (cons (lambda X (shen.let-macro X)) (cons (lambda X (shen.assoc-macro X)) (cons (lambda X (shen.make-string-macro X)) (cons (lambda X (shen.output-macro X)) (cons (lambda X (shen.input-macro X)) (cons (lambda X (shen.error-macro X)) (cons (lambda X (shen.prolog-macro X)) (cons (lambda X (shen.synonyms-macro X)) (cons (lambda X (shen.nl-macro X)) (cons (lambda X (shen.@s-macro X)) (cons (lambda X (shen.defprolog-macro X)) (cons (lambda X (shen.function-macro X)) ())))))))))))))))))))

(set shen.*gensym* 0)

(set shen.*tracking* ())

(set shen.*alphabet* (cons A (cons B (cons C (cons D (cons E (cons F (cons G (cons H (cons I (cons J (cons K (cons L (cons M (cons N (cons O (cons P (cons Q (cons R (cons S (cons T (cons U (cons V (cons W (cons X (cons Y (cons Z ())))))))))))))))))))))))))))

(set shen.*special* (cons @p (cons @s (cons @v (cons cons (cons lambda (cons let (cons where (cons set (cons open ()))))))))))

(set shen.*extraspecial* (cons define (cons shen.process-datatype (cons input+ (cons defcc (cons shen.read+ (cons defmacro ())))))))

(set shen.*spy* false)

(set shen.*datatypes* ())

(set shen.*alldatatypes* ())

(set shen.*shen-type-theory-enabled?* true)

(set shen.*synonyms* ())

(set shen.*system* ())

(set shen.*signedfuncs* ())

(set shen.*maxcomplexity* 128)

(set shen.*occurs* true)

(set shen.*maxinferences* 1000000)

(set *maximum-print-sequence-size* 20)

(set shen.*catch* 0)

(set shen.*call* 0)

(set shen.*infs* 0)

(set *hush* false)

(set shen.*optimise* false)

(set *version* "Shen 20.1")

(if (not (bound? *home-directory*)) (set *home-directory* "") shen.skip)

(if (not (bound? *sterror*)) (set *sterror* (value *stoutput*)) shen.skip)

(if (not (bound? *argv*)) (set *argv* (cons "shen" ())) shen.skip)

(defun shen.initialise_arity_table (V292) (cond ((= () V292) ()) ((and (cons? V292) (cons? (tl V292))) (let DecArity (put (hd V292) arity (hd (tl V292)) (value *property-vector*)) (shen.initialise_arity_table (tl (tl V292))))) (true (shen.f_error shen.initialise_arity_table))))

(defun arity (V294) (get/or V294 arity (freeze -1) (value *property-vector*)))

(shen.initialise_arity_table (cons abort (cons 0 (cons absvector? (cons 1 (cons absvector (cons 1 (cons adjoin (cons 2 (cons and (cons 2 (cons append (cons 2 (cons arity (cons 1 (cons assoc (cons 2 (cons boolean? (cons 1 (cons bound? (cons 1 (cons cd (cons 1 (cons close (cons 1 (cons compile (cons 3 (cons concat (cons 2 (cons cons (cons 2 (cons cons? (cons 1 (cons command-line (cons 0 (cons cn (cons 2 (cons declare (cons 2 (cons destroy (cons 1 (cons difference (cons 2 (cons do (cons 2 (cons element? (cons 2 (cons empty? (cons 1 (cons enable-type-theory (cons 1 (cons error-to-string (cons 1 (cons shen.interror (cons 2 (cons eval (cons 1 (cons eval-kl (cons 1 (cons exit (cons 1 (cons explode (cons 1 (cons external (cons 1 (cons fail-if (cons 2 (cons fail (cons 0 (cons fix (cons 2 (cons fold-left (cons 3 (cons fold-right (cons 3 (cons filter (cons 2 (cons for-each (cons 2 (cons findall (cons 5 (cons freeze (cons 1 (cons fst (cons 1 (cons gensym (cons 1 (cons get (cons 3 (cons get/or (cons 4 (cons get-time (cons 1 (cons address-> (cons 3 (cons <-address (cons 2 (cons <-address/or (cons 3 (cons <-vector (cons 2 (cons <-vector/or (cons 3 (cons > (cons 2 (cons >= (cons 2 (cons = (cons 2 (cons hash (cons 2 (cons hd (cons 1 (cons hdv (cons 1 (cons hdstr (cons 1 (cons head (cons 1 (cons if (cons 3 (cons integer? (cons 1 (cons intern (cons 1 (cons identical (cons 4 (cons inferences (cons 0 (cons input (cons 1 (cons input+ (cons 2 (cons implementation (cons 0 (cons intersection (cons 2 (cons internal (cons 1 (cons it (cons 0 (cons kill (cons 0 (cons language (cons 0 (cons length (cons 1 (cons limit (cons 1 (cons lineread (cons 1 (cons load (cons 1 (cons < (cons 2 (cons <= (cons 2 (cons vector (cons 1 (cons macroexpand (cons 1 (cons map (cons 2 (cons mapcan (cons 2 (cons maxinferences (cons 1 (cons nl (cons 1 (cons not (cons 1 (cons nth (cons 2 (cons n->string (cons 1 (cons number? (cons 1 (cons occurs-check (cons 1 (cons occurrences (cons 2 (cons occurs-check (cons 1 (cons open (cons 2 (cons optimise (cons 1 (cons or (cons 2 (cons os (cons 0 (cons package (cons 3 (cons package? (cons 1 (cons port (cons 0 (cons porters (cons 0 (cons pos (cons 2 (cons print (cons 1 (cons profile (cons 1 (cons profile-results (cons 1 (cons pr (cons 2 (cons ps (cons 1 (cons preclude (cons 1 (cons preclude-all-but (cons 1 (cons protect (cons 1 (cons address-> (cons 3 (cons put (cons 4 (cons shen.reassemble (cons 2 (cons read-file-as-string (cons 1 (cons read-file (cons 1 (cons read-file-as-charlist (cons 1 (cons read-file-as-bytelist (cons 1 (cons read (cons 1 (cons read-byte (cons 1 (cons read-from-string (cons 1 (cons read-char-code (cons 1 (cons receive (cons 1 (cons release (cons 0 (cons remove (cons 2 (cons shen.require (cons 3 (cons reverse (cons 1 (cons set (cons 2 (cons simple-error (cons 1 (cons snd (cons 1 (cons specialise (cons 1 (cons spy (cons 1 (cons step (cons 1 (cons stinput (cons 0 (cons stoutput (cons 0 (cons sterror (cons 0 (cons string->n (cons 1 (cons string->symbol (cons 1 (cons string? (cons 1 (cons str (cons 1 (cons subst (cons 3 (cons sum (cons 1 (cons symbol? (cons 1 (cons systemf (cons 1 (cons tail (cons 1 (cons tl (cons 1 (cons tc (cons 1 (cons tc? (cons 0 (cons thaw (cons 1 (cons tlstr (cons 1 (cons track (cons 1 (cons trap-error (cons 2 (cons tuple? (cons 1 (cons type (cons 2 (cons return (cons 3 (cons undefmacro (cons 1 (cons unput (cons 3 (cons unprofile (cons 1 (cons unify (cons 4 (cons unify! (cons 4 (cons union (cons 2 (cons untrack (cons 1 (cons unspecialise (cons 1 (cons undefmacro (cons 1 (cons vector (cons 1 (cons vector? (cons 1 (cons vector-> (cons 3 (cons value (cons 1 (cons value/or (cons 2 (cons variable? (cons 1 (cons version (cons 0 (cons write-byte (cons 2 (cons write-to-file (cons 2 (cons y-or-n? (cons 1 (cons + (cons 2 (cons * (cons 2 (cons / (cons 2 (cons - (cons 2 (cons == (cons 2 (cons <e> (cons 1 (cons <!> (cons 1 (cons @p (cons 2 (cons @v (cons 2 (cons @s (cons 2 (cons preclude (cons 1 (cons include (cons 1 (cons preclude-all-but (cons 1 (cons include-all-but (cons 1 (cons dict (cons 1 (cons dict? (cons 1 (cons dict-count (cons 1 (cons dict-> (cons 3 (cons <-dict/or (cons 3 (cons <-dict (cons 2 (cons dict-rm (cons 2 (cons dict-fold (cons 3 (cons dict-keys (cons 1 (cons dict-values (cons 1 ())))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

(defun systemf (V296) (let Shen (intern "shen") (let External (get Shen shen.external-symbols (value *property-vector*)) (let Place (put Shen shen.external-symbols (adjoin V296 External) (value *property-vector*)) V296))))

(defun adjoin (V299 V300) (if (element? V299 V300) V300 (cons V299 V300)))

(put (intern "shen") shen.external-symbols (cons ! (cons } (cons { (cons --> (cons <-- (cons && (cons : (cons ; (cons :- (cons := (cons _ (cons *language* (cons *implementation* (cons *stinput* (cons *stoutput* (cons *sterror* (cons *home-directory* (cons *version* (cons *argv* (cons *maximum-print-sequence-size* (cons *macros* (cons *os* (cons *release* (cons *property-vector* (cons *port* (cons *porters* (cons *hush* (cons @v (cons @p (cons @s (cons <- (cons -> (cons <e> (cons <!> (cons == (cons = (cons >= (cons > (cons /. (cons =! (cons $ (cons - (cons / (cons * (cons + (cons <= (cons < (cons >> (cons (vector 0) (cons y-or-n? (cons write-to-file (cons write-byte (cons where (cons when (cons warn (cons version (cons verified (cons variable? (cons value (cons value/or (cons vector-> (cons <-vector (cons <-vector/or (cons vector (cons vector? (cons unspecialise (cons untrack (cons unit (cons shen.unix (cons union (cons unify (cons unify! (cons unput (cons unprofile (cons undefmacro (cons return (cons type (cons tuple? (cons true (cons trap-error (cons track (cons time (cons thaw (cons tc? (cons tc (cons tl (cons tlstr (cons tlv (cons tail (cons systemf (cons synonyms (cons symbol (cons symbol? (cons string->symbol (cons sum (cons subst (cons string? (cons string->n (cons stream (cons string (cons stinput (cons sterror (cons stoutput (cons step (cons spy (cons specialise (cons snd (cons simple-error (cons set (cons save (cons str (cons run (cons reverse (cons remove (cons release (cons read (cons receive (cons read-file (cons read-file-as-bytelist (cons read-file-as-string (cons read-byte (cons read-file-as-charlist (cons read-char-code (cons read-from-string (cons package? (cons put (cons preclude (cons preclude-all-but (cons ps (cons prolog? (cons protect (cons profile-results (cons profile (cons print (cons pr (cons pos (cons porters (cons port (cons package (cons output (cons out (cons os (cons or (cons optimise (cons open (cons occurrences (cons occurs-check (cons n->string (cons number? (cons number (cons null (cons nth (cons not (cons nl (cons mode (cons macroexpand (cons maxinferences (cons mapcan (cons map (cons make-string (cons load (cons loaded (cons list (cons lineread (cons limit (cons length (cons let (cons lazy (cons lambda (cons language (cons kill (cons is (cons intersection (cons inferences (cons intern (cons integer? (cons input (cons input+ (cons include (cons include-all-but (cons it (cons in (cons internal (cons implementation (cons if (cons identical (cons head (cons hd (cons hdv (cons hdstr (cons hash (cons get (cons get/or (cons get-time (cons gensym (cons function (cons fst (cons freeze (cons fix (cons file (cons fail (cons fail-if (cons fwhen (cons findall (cons for-each (cons fold-right (cons fold-left (cons filter (cons false (cons enable-type-theory (cons explode (cons external (cons exception (cons eval-kl (cons eval (cons error-to-string (cons error (cons empty? (cons exit (cons element? (cons do (cons difference (cons destroy (cons defun (cons define (cons defmacro (cons defcc (cons defprolog (cons declare (cons datatype (cons cut (cons cn (cons cons? (cons cons (cons cond (cons concat (cons compile (cons cd (cons cases (cons call (cons close (cons bind (cons bound? (cons boolean? (cons boolean (cons bar! (cons assoc (cons arity (cons abort (cons append (cons and (cons adjoin (cons <-address (cons <-address/or (cons address-> (cons absvector? (cons absvector (cons dict (cons dict? (cons dict-count (cons dict-> (cons <-dict/or (cons <-dict (cons dict-rm (cons dict-fold (cons dict-keys (cons dict-values (cons command-line ())))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) (value *property-vector*))

(defun shen.lambda-form-entry (V302) (cond ((= package V302) ()) ((= receive V302) ()) (true (let ArityF (arity V302) (if (= ArityF -1) () (if (= ArityF 0) () (cons (cons V302 (eval-kl (shen.lambda-form V302 ArityF))) ())))))))

(defun shen.lambda-form (V305 V306) (cond ((= 0 V306) V305) (true (let X (gensym V) (cons lambda (cons X (cons (shen.lambda-form (shen.add-end V305 X) (- V306 1)) ())))))))

(defun shen.add-end (V309 V310) (cond ((cons? V309) (append V309 (cons V310 ()))) (true (cons V309 (cons V310 ())))))

(defun shen.set-lambda-form-entry (V312) (cond ((cons? V312) (put (hd V312) shen.lambda-form (tl V312) (value *property-vector*))) (true (shen.f_error shen.set-lambda-form-entry))))

(for-each (lambda Entry (shen.set-lambda-form-entry Entry)) (cons (cons shen.datatype-error (lambda X (shen.datatype-error X))) (cons (cons shen.tuple (lambda X (shen.tuple X))) (cons (cons shen.pvar (lambda X (shen.pvar X))) (cons (cons shen.dictionary (lambda X (shen.dictionary X))) (cons (cons @v (lambda V1 (lambda V2 (@v V1 V2)))) (cons (cons @p (lambda V3 (lambda V4 (@p V3 V4)))) (cons (cons @s (lambda V5 (lambda V6 (@s V5 V6)))) (cons (cons <e> (lambda V7 (<e> V7))) (cons (cons <!> (lambda V8 (<!> V8))) (cons (cons == (lambda V9 (lambda V10 (== V9 V10)))) (cons (cons = (lambda V11 (lambda V12 (= V11 V12)))) (cons (cons >= (lambda V13 (lambda V14 (>= V13 V14)))) (cons (cons > (lambda V15 (lambda V16 (> V15 V16)))) (cons (cons - (lambda V17 (lambda V18 (- V17 V18)))) (cons (cons / (lambda V19 (lambda V20 (/ V19 V20)))) (cons (cons * (lambda V21 (lambda V22 (* V21 V22)))) (cons (cons + (lambda V23 (lambda V24 (+ V23 V24)))) (cons (cons <= (lambda V25 (lambda V26 (<= V25 V26)))) (cons (cons < (lambda V27 (lambda V28 (< V27 V28)))) (cons (cons y-or-n? (lambda V29 (y-or-n? V29))) (cons (cons write-to-file (lambda V30 (lambda V31 (write-to-file V30 V31)))) (cons (cons write-byte (lambda V32 (lambda V33 (write-byte V32 V33)))) (cons (cons variable? (lambda V34 (variable? V34))) (cons (cons value (lambda V35 (value V35))) (cons (cons value/or (lambda V36 (lambda V37 (value/or V36 V37)))) (cons (cons vector-> (lambda V38 (lambda V39 (lambda V40 (vector-> V38 V39 V40))))) (cons (cons <-vector (lambda V41 (lambda V42 (<-vector V41 V42)))) (cons (cons <-vector/or (lambda V43 (lambda V44 (lambda V45 (<-vector/or V43 V44 V45))))) (cons (cons vector (lambda V46 (vector V46))) (cons (cons vector? (lambda V47 (vector? V47))) (cons (cons unspecialise (lambda V48 (unspecialise V48))) (cons (cons untrack (lambda V49 (untrack V49))) (cons (cons union (lambda V50 (lambda V51 (union V50 V51)))) (cons (cons unify (lambda V52 (lambda V53 (lambda V54 (lambda V55 (unify V52 V53 V54 V55)))))) (cons (cons unify! (lambda V56 (lambda V57 (lambda V58 (lambda V59 (unify! V56 V57 V58 V59)))))) (cons (cons unput (lambda V60 (lambda V61 (lambda V62 (unput V60 V61 V62))))) (cons (cons unprofile (lambda V63 (unprofile V63))) (cons (cons undefmacro (lambda V64 (undefmacro V64))) (cons (cons return (lambda V65 (lambda V66 (lambda V67 (return V65 V66 V67))))) (cons (cons type (lambda V68 (lambda V69 (type V68 V69)))) (cons (cons tuple? (lambda V70 (tuple? V70))) (cons (cons trap-error (lambda V71 (lambda V72 (trap-error V71 V72)))) (cons (cons track (lambda V73 (track V73))) (cons (cons thaw (lambda V74 (thaw V74))) (cons (cons tc (lambda V75 (tc V75))) (cons (cons tl (lambda V76 (tl V76))) (cons (cons tlstr (lambda V77 (tlstr V77))) (cons (cons tail (lambda V78 (tail V78))) (cons (cons systemf (lambda V79 (systemf V79))) (cons (cons symbol? (lambda V80 (symbol? V80))) (cons (cons string->symbol (lambda V81 (string->symbol V81))) (cons (cons sum (lambda V82 (sum V82))) (cons (cons subst (lambda V83 (lambda V84 (lambda V85 (subst V83 V84 V85))))) (cons (cons string? (lambda V86 (string? V86))) (cons (cons string->n (lambda V87 (string->n V87))) (cons (cons step (lambda V88 (step V88))) (cons (cons spy (lambda V89 (spy V89))) (cons (cons specialise (lambda V90 (specialise V90))) (cons (cons snd (lambda V91 (snd V91))) (cons (cons simple-error (lambda V92 (simple-error V92))) (cons (cons set (lambda V93 (lambda V94 (set V93 V94)))) (cons (cons str (lambda V95 (str V95))) (cons (cons reverse (lambda V96 (reverse V96))) (cons (cons remove (lambda V97 (lambda V98 (remove V97 V98)))) (cons (cons read (lambda V99 (read V99))) (cons (cons read-file (lambda V100 (read-file V100))) (cons (cons read-file-as-bytelist (lambda V101 (read-file-as-bytelist V101))) (cons (cons read-file-as-string (lambda V102 (read-file-as-string V102))) (cons (cons read-byte (lambda V103 (read-byte V103))) (cons (cons read-file-as-charlist (lambda V104 (read-file-as-charlist V104))) (cons (cons read-char-code (lambda V105 (read-char-code V105))) (cons (cons read-from-string (lambda V106 (read-from-string V106))) (cons (cons package? (lambda V107 (package? V107))) (cons (cons put (lambda V108 (lambda V109 (lambda V110 (lambda V111 (put V108 V109 V110 V111)))))) (cons (cons preclude (lambda V112 (preclude V112))) (cons (cons preclude-all-but (lambda V113 (preclude-all-but V113))) (cons (cons ps (lambda V114 (ps V114))) (cons (cons protect (lambda V115 (protect V115))) (cons (cons profile-results (lambda V116 (profile-results V116))) (cons (cons profile (lambda V117 (profile V117))) (cons (cons print (lambda V118 (print V118))) (cons (cons pr (lambda V119 (lambda V120 (pr V119 V120)))) (cons (cons pos (lambda V121 (lambda V122 (pos V121 V122)))) (cons (cons or (lambda V123 (lambda V124 (or V123 V124)))) (cons (cons optimise (lambda V125 (optimise V125))) (cons (cons open (lambda V126 (lambda V127 (open V126 V127)))) (cons (cons occurrences (lambda V128 (lambda V129 (occurrences V128 V129)))) (cons (cons occurs-check (lambda V130 (occurs-check V130))) (cons (cons n->string (lambda V131 (n->string V131))) (cons (cons number? (lambda V132 (number? V132))) (cons (cons nth (lambda V133 (lambda V134 (nth V133 V134)))) (cons (cons not (lambda V135 (not V135))) (cons (cons nl (lambda V136 (nl V136))) (cons (cons macroexpand (lambda V137 (macroexpand V137))) (cons (cons maxinferences (lambda V138 (maxinferences V138))) (cons (cons mapcan (lambda V139 (lambda V140 (mapcan V139 V140)))) (cons (cons map (lambda V141 (lambda V142 (map V141 V142)))) (cons (cons load (lambda V143 (load V143))) (cons (cons lineread (lambda V144 (lineread V144))) (cons (cons limit (lambda V145 (limit V145))) (cons (cons length (lambda V146 (length V146))) (cons (cons intersection (lambda V147 (lambda V148 (intersection V147 V148)))) (cons (cons intern (lambda V149 (intern V149))) (cons (cons integer? (cons (lambda V150 (integer? V150)) ())) (cons (cons input (lambda V151 (input V151))) (cons (cons input+ (lambda V152 (lambda V153 (input+ V152 V153)))) (cons (cons include (lambda V154 (include V154))) (cons (cons include-all-but (lambda V155 (include-all-but V155))) (cons (cons internal (lambda V156 (internal V156))) (cons (cons if (lambda V157 (lambda V158 (lambda V159 (if V157 V158 V159))))) (cons (cons identical (lambda V160 (lambda V161 (lambda V162 (lambda V163 (identical V160 V161 V162 V163)))))) (cons (cons head (lambda V164 (head V164))) (cons (cons hd (lambda V165 (hd V165))) (cons (cons hdv (lambda V166 (hdv V166))) (cons (cons hdstr (lambda V167 (hdstr V167))) (cons (cons hash (lambda V168 (lambda V169 (hash V168 V169)))) (cons (cons get (lambda V170 (lambda V171 (lambda V172 (get V170 V171 V172))))) (cons (cons get/or (lambda V173 (lambda V174 (lambda V175 (lambda V176 (get/or V173 V174 V175 V176)))))) (cons (cons get-time (lambda V177 (get-time V177))) (cons (cons gensym (lambda V178 (gensym V178))) (cons (cons fst (lambda V179 (fst V179))) (cons (cons freeze (lambda V180 (freeze V180))) (cons (cons fix (lambda V181 (lambda V182 (fix V181 V182)))) (cons (cons fail-if (lambda V183 (lambda V184 (fail-if V183 V184)))) (cons (cons findall (lambda V185 (lambda V186 (lambda V187 (lambda V188 (lambda V189 (findall V185 V186 V187 V188 V189))))))) (cons (cons for-each (lambda V190 (lambda V191 (for-each V190 V191)))) (cons (cons fold-right (lambda V192 (lambda V193 (lambda V194 (fold-right V192 V193 V194))))) (cons (cons fold-left (lambda V195 (lambda V196 (lambda V197 (fold-left V195 V196 V197))))) (cons (cons filter (lambda V198 (lambda V199 (filter V198 V199)))) (cons (cons enable-type-theory (lambda V200 (enable-type-theory V200))) (cons (cons explode (lambda V201 (explode V201))) (cons (cons external (lambda V202 (external V202))) (cons (cons eval-kl (lambda V203 (eval-kl V203))) (cons (cons eval (lambda V204 (eval V204))) (cons (cons error-to-string (lambda V205 (error-to-string V205))) (cons (cons empty? (lambda V206 (empty? V206))) (cons (cons exit (lambda V207 (exit V207))) (cons (cons element? (lambda V208 (lambda V209 (element? V208 V209)))) (cons (cons do (lambda V210 (lambda V211 (do V210 V211)))) (cons (cons difference (lambda V212 (lambda V213 (difference V212 V213)))) (cons (cons destroy (lambda V214 (destroy V214))) (cons (cons declare (lambda V215 (lambda V216 (declare V215 V216)))) (cons (cons cn (lambda V217 (lambda V218 (cn V217 V218)))) (cons (cons cons? (lambda V219 (cons? V219))) (cons (cons cons (lambda V220 (lambda V221 (cons V220 V221)))) (cons (cons concat (lambda V222 (lambda V223 (concat V222 V223)))) (cons (cons compile (lambda V224 (lambda V225 (lambda V226 (compile V224 V225 V226))))) (cons (cons cd (lambda V227 (cd V227))) (cons (cons close (lambda V228 (close V228))) (cons (cons bound? (lambda V229 (bound? V229))) (cons (cons boolean? (lambda V230 (boolean? V230))) (cons (cons assoc (lambda V231 (lambda V232 (assoc V231 V232)))) (cons (cons arity (lambda V233 (arity V233))) (cons (cons append (lambda V234 (lambda V235 (append V234 V235)))) (cons (cons and (lambda V236 (lambda V237 (and V236 V237)))) (cons (cons adjoin (lambda V238 (lambda V239 (adjoin V238 V239)))) (cons (cons <-address (lambda V240 (lambda V241 (<-address V240 V241)))) (cons (cons <-address/or (lambda V242 (lambda V243 (lambda V244 (<-address/or V242 V243 V244))))) (cons (cons address-> (lambda V245 (lambda V246 (lambda V247 (address-> V245 V246 V247))))) (cons (cons absvector? (lambda V248 (absvector? V248))) (cons (cons absvector (lambda V249 (absvector V249))) (cons (cons dict (lambda V250 (dict V250))) (cons (cons dict? (lambda V251 (dict? V251))) (cons (cons dict-count (lambda V252 (dict-count V252))) (cons (cons dict-> (lambda V253 (lambda V254 (lambda V255 (dict-> V253 V254 V255))))) (cons (cons <-dict/or (lambda V256 (lambda V257 (lambda V258 (<-dict/or V256 V257 V258))))) (cons (cons <-dict (lambda V259 (lambda V260 (<-dict V259 V260)))) (cons (cons dict-rm (lambda V261 (lambda V262 (dict-rm V261 V262)))) (cons (cons dict-fold (lambda V263 (lambda V264 (lambda V265 (dict-fold V263 V264 V265))))) (cons (cons dict-keys (lambda V266 (dict-keys V266))) (cons (cons dict-values (lambda V267 (dict-values V267))) ()))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

(defun specialise (V314) (do (set shen.*special* (cons V314 (value shen.*special*))) V314))

(defun unspecialise (V316) (do (set shen.*special* (remove V316 (value shen.*special*))) V316))



