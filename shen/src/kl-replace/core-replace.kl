"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.shen->kl (V29 V30) (compile (lambda X (shen.<define> X)) (cons V29 V30) (lambda X (shen.shen-syntax-error V29 X))))

(defun shen.shen-syntax-error (V37 V38) (cond ((cons? V38) (simple-error (cn "syntax error in " (shen.app V37 (cn " here:

 " (shen.app (shen.next-50 50 (hd V38)) "
" shen.a)) shen.a)))) (true (simple-error (cn "syntax error in " (shen.app V37 "
" shen.a))))))

(defun shen.<define> (V40) (let YaccParse (let Parse_shen.<name> (shen.<name> V40) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<signature> (shen.<signature> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<name> (shen.<name> V40) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) YaccParse)))

(set shen.*check-sysfunc-in-name* true)

(defun shen.<name> (V42) (if (cons? (hd V42)) (let Parse_X (hd (hd V42)) (shen.pair (hd (shen.pair (tl (hd V42)) (shen.hdtl V42))) (if (and (symbol? Parse_X) (or (not (value shen.*check-sysfunc-in-name*)) (not (shen.sysfunc? Parse_X)))) Parse_X (simple-error (shen.app Parse_X " is not a legitimate function name.
" shen.a))))) (fail)))

(defun shen.sysfunc? (V44) (element? V44 (get (intern "shen") shen.external-symbols (value *property-vector*))))

(defun shen.<signature> (V46) (if (and (cons? (hd V46)) (= { (hd (hd V46)))) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (tl (hd V46)) (shen.hdtl V46))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (and (cons? (hd Parse_shen.<signature-help>)) (= } (hd (hd Parse_shen.<signature-help>)))) (shen.pair (hd (shen.pair (tl (hd Parse_shen.<signature-help>)) (shen.hdtl Parse_shen.<signature-help>))) (shen.demodulate (shen.curry-type (shen.hdtl Parse_shen.<signature-help>)))) (fail)) (fail))) (fail)))

(defun shen.curry-type (V48) (cond ((and (cons? V48) (and (cons? (tl V48)) (and (= --> (hd (tl V48))) (and (cons? (tl (tl V48))) (and (cons? (tl (tl (tl V48)))) (= --> (hd (tl (tl (tl V48)))))))))) (shen.curry-type (cons (hd V48) (cons --> (cons (tl (tl V48)) ()))))) ((and (cons? V48) (and (cons? (tl V48)) (and (= * (hd (tl V48))) (and (cons? (tl (tl V48))) (and (cons? (tl (tl (tl V48)))) (= * (hd (tl (tl (tl V48)))))))))) (shen.curry-type (cons (hd V48) (cons * (cons (tl (tl V48)) ()))))) ((cons? V48) (map (lambda Z (shen.curry-type Z)) V48)) (true V48)))

(defun shen.<signature-help> (V50) (let YaccParse (if (cons? (hd V50)) (let Parse_X (hd (hd V50)) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (tl (hd V50)) (shen.hdtl V50))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (not (element? Parse_X (cons { (cons } ())))) (shen.pair (hd Parse_shen.<signature-help>) (cons Parse_X (shen.hdtl Parse_shen.<signature-help>))) (fail)) (fail)))) (fail)) (if (= YaccParse (fail)) (let Parse_<e> (<e> V50) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<rules> (V52) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V52) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V52) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) ())) (fail))) YaccParse)))

(defun shen.<rule> (V54) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V54) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (hd (hd Parse_shen.<action>)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd Parse_shen.<action>)) (shen.hdtl Parse_shen.<action>))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<action>) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V54) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<action>) ()))) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V54) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (hd (hd Parse_shen.<action>)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd Parse_shen.<action>)) (shen.hdtl Parse_shen.<action>))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<patterns> (shen.<patterns> V54) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) (fail))) (fail)) (fail))) YaccParse)) YaccParse)) YaccParse)))

(defun shen.fail_if (V57 V58) (if (V57 V58) (fail) V58))

(defun shen.succeeds? (V64) (cond ((= V64 (fail)) false) (true true)))

(defun shen.<patterns> (V66) (let YaccParse (let Parse_shen.<pattern> (shen.<pattern> V66) (if (not (= (fail) Parse_shen.<pattern>)) (let Parse_shen.<patterns> (shen.<patterns> Parse_shen.<pattern>) (if (not (= (fail) Parse_shen.<patterns>)) (shen.pair (hd Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<pattern>) (shen.hdtl Parse_shen.<patterns>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V66) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<pattern> (V73) (let YaccParse (if (and (cons? (hd V73)) (cons? (hd (hd V73)))) (if (and (cons? (hd (shen.pair (hd (hd V73)) (hd (tl V73))))) (= @p (hd (hd (shen.pair (hd (hd V73)) (hd (tl V73))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V73)) (hd (tl V73))))) (shen.hdtl (shen.pair (hd (hd V73)) (hd (tl V73)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V73)) (hd (tl V73)))) (cons @p (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V73)) (cons? (hd (hd V73)))) (if (and (cons? (hd (shen.pair (hd (hd V73)) (hd (tl V73))))) (= cons (hd (hd (shen.pair (hd (hd V73)) (hd (tl V73))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V73)) (hd (tl V73))))) (shen.hdtl (shen.pair (hd (hd V73)) (hd (tl V73)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V73)) (hd (tl V73)))) (cons cons (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V73)) (cons? (hd (hd V73)))) (if (and (cons? (hd (shen.pair (hd (hd V73)) (hd (tl V73))))) (= @v (hd (hd (shen.pair (hd (hd V73)) (hd (tl V73))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V73)) (hd (tl V73))))) (shen.hdtl (shen.pair (hd (hd V73)) (hd (tl V73)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V73)) (hd (tl V73)))) (cons @v (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V73)) (cons? (hd (hd V73)))) (if (and (cons? (hd (shen.pair (hd (hd V73)) (hd (tl V73))))) (= @s (hd (hd (shen.pair (hd (hd V73)) (hd (tl V73))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V73)) (hd (tl V73))))) (shen.hdtl (shen.pair (hd (hd V73)) (hd (tl V73)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V73)) (hd (tl V73)))) (cons @s (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V73)) (cons? (hd (hd V73)))) (if (and (cons? (hd (shen.pair (hd (hd V73)) (hd (tl V73))))) (= vector (hd (hd (shen.pair (hd (hd V73)) (hd (tl V73))))))) (if (and (cons? (hd (shen.pair (tl (hd (shen.pair (hd (hd V73)) (hd (tl V73))))) (shen.hdtl (shen.pair (hd (hd V73)) (hd (tl V73))))))) (= 0 (hd (hd (shen.pair (tl (hd (shen.pair (hd (hd V73)) (hd (tl V73))))) (shen.hdtl (shen.pair (hd (hd V73)) (hd (tl V73))))))))) (shen.pair (hd (shen.pair (tl (hd V73)) (hd (tl V73)))) (cons vector (cons 0 ()))) (fail)) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (cons? (hd V73)) (let Parse_X (hd (hd V73)) (if (cons? Parse_X) (shen.pair (hd (shen.pair (tl (hd V73)) (shen.hdtl V73))) (shen.constructor-error Parse_X)) (fail))) (fail)) (if (= YaccParse (fail)) (let Parse_shen.<simple_pattern> (shen.<simple_pattern> V73) (if (not (= (fail) Parse_shen.<simple_pattern>)) (shen.pair (hd Parse_shen.<simple_pattern>) (shen.hdtl Parse_shen.<simple_pattern>)) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shen.constructor-error (V75) (simple-error (shen.app V75 " is not a legitimate constructor
" shen.a)))

(defun shen.<simple_pattern> (V77) (let YaccParse (if (cons? (hd V77)) (let Parse_X (hd (hd V77)) (if (= Parse_X _) (shen.pair (hd (shen.pair (tl (hd V77)) (shen.hdtl V77))) (gensym Parse_Y)) (fail))) (fail)) (if (= YaccParse (fail)) (if (cons? (hd V77)) (let Parse_X (hd (hd V77)) (if (not (element? Parse_X (cons -> (cons <- ())))) (shen.pair (hd (shen.pair (tl (hd V77)) (shen.hdtl V77))) Parse_X) (fail))) (fail)) YaccParse)))

(defun shen.<pattern1> (V79) (let Parse_shen.<pattern> (shen.<pattern> V79) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<pattern2> (V81) (let Parse_shen.<pattern> (shen.<pattern> V81) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<action> (V83) (if (cons? (hd V83)) (let Parse_X (hd (hd V83)) (shen.pair (hd (shen.pair (tl (hd V83)) (shen.hdtl V83))) Parse_X)) (fail)))

(defun shen.<guard> (V85) (if (cons? (hd V85)) (let Parse_X (hd (hd V85)) (shen.pair (hd (shen.pair (tl (hd V85)) (shen.hdtl V85))) Parse_X)) (fail)))

(defun shen.compile_to_machine_code (V88 V89) (let Lambda+ (shen.compile_to_lambda+ V88 V89) (let KL (shen.compile_to_kl V88 Lambda+) (let Record (shen.record-source V88 KL) KL))))

(defun shen.record-source (V94 V95) (cond ((value shen.*installing-kl*) shen.skip) (true (put V94 shen.source V95 (value *property-vector*)))))

(defun shen.compile_to_lambda+ (V98 V99) (let Arity (shen.aritycheck V98 V99) (let UpDateSymbolTable (shen.update-symbol-table V98 Arity) (let Free (for-each (lambda Rule (shen.free_variable_check V98 Rule)) V99) (let Variables (shen.parameters Arity) (let Strip (map (lambda X (shen.strip-protect X)) V99) (let Abstractions (map (lambda X (shen.abstract_rule X)) Strip) (let Applications (map (lambda X (shen.application_build Variables X)) Abstractions) (cons Variables (cons Applications ()))))))))))

(defun shen.update-symbol-table (V102 V103) (cond ((= 0 V103) shen.skip) (true (put V102 shen.lambda-form (eval-kl (shen.lambda-form V102 V103)) (value *property-vector*)))))

(defun shen.free_variable_check (V106 V107) (cond ((and (cons? V107) (and (cons? (tl V107)) (= () (tl (tl V107))))) (let Bound (shen.extract_vars (hd V107)) (let Free (shen.extract_free_vars Bound (hd (tl V107))) (shen.free_variable_warnings V106 Free)))) (true (shen.f_error shen.free_variable_check))))

(defun shen.extract_vars (V109) (cond ((variable? V109) (cons V109 ())) ((cons? V109) (union (shen.extract_vars (hd V109)) (shen.extract_vars (tl V109)))) (true ())))

(defun shen.extract_free_vars (V121 V122) (cond ((and (cons? V122) (and (cons? (tl V122)) (and (= () (tl (tl V122))) (= (hd V122) protect)))) ()) ((and (variable? V122) (not (element? V122 V121))) (cons V122 ())) ((and (cons? V122) (and (= lambda (hd V122)) (and (cons? (tl V122)) (and (cons? (tl (tl V122))) (= () (tl (tl (tl V122)))))))) (shen.extract_free_vars (cons (hd (tl V122)) V121) (hd (tl (tl V122))))) ((and (cons? V122) (and (= let (hd V122)) (and (cons? (tl V122)) (and (cons? (tl (tl V122))) (and (cons? (tl (tl (tl V122)))) (= () (tl (tl (tl (tl V122)))))))))) (union (shen.extract_free_vars V121 (hd (tl (tl V122)))) (shen.extract_free_vars (cons (hd (tl V122)) V121) (hd (tl (tl (tl V122))))))) ((cons? V122) (union (shen.extract_free_vars V121 (hd V122)) (shen.extract_free_vars V121 (tl V122)))) (true ())))

(defun shen.free_variable_warnings (V127 V128) (cond ((= () V128) _) (true (simple-error (cn "error: the following variables are free in " (shen.app V127 (cn ": " (shen.app (shen.list_variables V128) "" shen.a)) shen.a))))))

(defun shen.list_variables (V130) (cond ((and (cons? V130) (= () (tl V130))) (cn (str (hd V130)) ".")) ((cons? V130) (cn (str (hd V130)) (cn ", " (shen.list_variables (tl V130))))) (true (shen.f_error shen.list_variables))))

(defun shen.strip-protect (V132) (cond ((and (cons? V132) (and (cons? (tl V132)) (and (= () (tl (tl V132))) (= (hd V132) protect)))) (shen.strip-protect (hd (tl V132)))) ((cons? V132) (map (lambda Z (shen.strip-protect Z)) V132)) (true V132)))

(defun shen.linearise (V134) (cond ((and (cons? V134) (and (cons? (tl V134)) (= () (tl (tl V134))))) (shen.linearise_help (shen.flatten (hd V134)) (hd V134) (hd (tl V134)))) (true (shen.f_error shen.linearise))))

(defun shen.flatten (V136) (cond ((= () V136) ()) ((cons? V136) (append (shen.flatten (hd V136)) (shen.flatten (tl V136)))) (true (cons V136 ()))))

(defun shen.linearise_help (V140 V141 V142) (cond ((= () V140) (cons V141 (cons V142 ()))) ((cons? V140) (if (and (variable? (hd V140)) (element? (hd V140) (tl V140))) (let Var (gensym (hd V140)) (let NewAction (cons where (cons (cons = (cons (hd V140) (cons Var ()))) (cons V142 ()))) (let NewPatts (shen.linearise_X (hd V140) Var V141) (shen.linearise_help (tl V140) NewPatts NewAction)))) (shen.linearise_help (tl V140) V141 V142))) (true (shen.f_error shen.linearise_help))))

(defun shen.linearise_X (V155 V156 V157) (cond ((= V157 V155) V156) ((cons? V157) (let L (shen.linearise_X V155 V156 (hd V157)) (if (= L (hd V157)) (cons (hd V157) (shen.linearise_X V155 V156 (tl V157))) (cons L (tl V157))))) (true V157)))

(defun shen.aritycheck (V160 V161) (cond ((and (cons? V161) (and (cons? (hd V161)) (and (cons? (tl (hd V161))) (and (= () (tl (tl (hd V161)))) (= () (tl V161)))))) (do (shen.aritycheck-action (hd (tl (hd V161)))) (shen.aritycheck-name V160 (arity V160) (length (hd (hd V161)))))) ((and (cons? V161) (and (cons? (hd V161)) (and (cons? (tl (hd V161))) (and (= () (tl (tl (hd V161)))) (and (cons? (tl V161)) (and (cons? (hd (tl V161))) (and (cons? (tl (hd (tl V161)))) (= () (tl (tl (hd (tl V161)))))))))))) (if (= (length (hd (hd V161))) (length (hd (hd (tl V161))))) (do (shen.aritycheck-action (hd (tl (hd V161)))) (shen.aritycheck V160 (tl V161))) (simple-error (cn "arity error in " (shen.app V160 "
" shen.a))))) (true (shen.f_error shen.aritycheck))))

(defun shen.aritycheck-name (V174 V175 V176) (cond ((= -1 V175) V176) ((= V176 V175) V176) (true (do (shen.prhush (cn "
warning: changing the arity of " (shen.app V174 " can cause errors.
" shen.a)) (stoutput)) V176))))

(defun shen.aritycheck-action (V182) (cond ((cons? V182) (do (shen.aah (hd V182) (tl V182)) (for-each (lambda Y (shen.aritycheck-action Y)) V182))) (true shen.skip)))

(defun shen.aah (V185 V186) (let Arity (arity V185) (let Len (length V186) (if (and (> Arity -1) (> Len Arity)) (shen.prhush (cn "warning: " (shen.app V185 (cn " might not like " (shen.app Len (cn " argument" (shen.app (if (> Len 1) "s" "") ".
" shen.a)) shen.a)) shen.a)) (stoutput)) shen.skip))))

(defun shen.abstract_rule (V188) (cond ((and (cons? V188) (and (cons? (tl V188)) (= () (tl (tl V188))))) (shen.abstraction_build (hd V188) (hd (tl V188)))) (true (shen.f_error shen.abstract_rule))))

(defun shen.abstraction_build (V191 V192) (cond ((= () V191) V192) ((cons? V191) (cons /. (cons (hd V191) (cons (shen.abstraction_build (tl V191) V192) ())))) (true (shen.f_error shen.abstraction_build))))

(defun shen.parameters (V194) (cond ((= 0 V194) ()) (true (cons (gensym V) (shen.parameters (- V194 1))))))

(defun shen.application_build (V197 V198) (cond ((= () V197) V198) ((cons? V197) (shen.application_build (tl V197) (cons V198 (cons (hd V197) ())))) (true (shen.f_error shen.application_build))))

(defun shen.compile_to_kl (V201 V202) (cond ((and (cons? V202) (and (cons? (tl V202)) (= () (tl (tl V202))))) (let Arity (shen.store-arity V201 (length (hd V202))) (let Reduce (map (lambda X (shen.reduce X)) (hd (tl V202))) (let CondExpression (shen.cond-expression V201 (hd V202) Reduce) (let TypeTable (if (value shen.*optimise*) (shen.typextable (shen.get-type V201) (hd V202)) shen.skip) (let TypedCondExpression (if (value shen.*optimise*) (shen.assign-types (hd V202) TypeTable CondExpression) CondExpression) (cons defun (cons V201 (cons (hd V202) (cons TypedCondExpression ())))))))))) (true (shen.f_error shen.compile_to_kl))))

(defun shen.get-type (V208) (cond ((cons? V208) shen.skip) (true (let FType (assoc V208 (value shen.*signedfuncs*)) (if (empty? FType) shen.skip (tl FType))))))

(defun shen.typextable (V219 V220) (cond ((and (cons? V219) (and (cons? (tl V219)) (and (= --> (hd (tl V219))) (and (cons? (tl (tl V219))) (and (= () (tl (tl (tl V219)))) (cons? V220)))))) (if (variable? (hd V219)) (shen.typextable (hd (tl (tl V219))) (tl V220)) (cons (cons (hd V220) (hd V219)) (shen.typextable (hd (tl (tl V219))) (tl V220))))) (true ())))

(defun shen.assign-types (V224 V225 V226) (cond ((and (cons? V226) (and (= let (hd V226)) (and (cons? (tl V226)) (and (cons? (tl (tl V226))) (and (cons? (tl (tl (tl V226)))) (= () (tl (tl (tl (tl V226)))))))))) (cons let (cons (hd (tl V226)) (cons (shen.assign-types V224 V225 (hd (tl (tl V226)))) (cons (shen.assign-types (cons (hd (tl V226)) V224) V225 (hd (tl (tl (tl V226))))) ()))))) ((and (cons? V226) (and (= lambda (hd V226)) (and (cons? (tl V226)) (and (cons? (tl (tl V226))) (= () (tl (tl (tl V226)))))))) (cons lambda (cons (hd (tl V226)) (cons (shen.assign-types (cons (hd (tl V226)) V224) V225 (hd (tl (tl V226)))) ())))) ((and (cons? V226) (= cond (hd V226))) (cons cond (map (lambda Y (cons (shen.assign-types V224 V225 (hd Y)) (cons (shen.assign-types V224 V225 (hd (tl Y))) ()))) (tl V226)))) ((cons? V226) (let NewTable (shen.typextable (shen.get-type (hd V226)) (tl V226)) (cons (hd V226) (map (lambda Y (shen.assign-types V224 (append V225 NewTable) Y)) (tl V226))))) (true (let AtomType (assoc V226 V225) (if (cons? AtomType) (cons type (cons V226 (cons (tl AtomType) ()))) (if (element? V226 V224) V226 (shen.atom-type V226)))))))

(defun shen.atom-type (V228) (if (string? V228) (cons type (cons V228 (cons string ()))) (if (number? V228) (cons type (cons V228 (cons number ()))) (if (boolean? V228) (cons type (cons V228 (cons boolean ()))) (if (symbol? V228) (cons type (cons V228 (cons symbol ()))) V228)))))

(defun shen.store-arity (V233 V234) (cond ((value shen.*installing-kl*) shen.skip) (true (put V233 arity V234 (value *property-vector*)))))

(defun shen.reduce (V236) (do (set shen.*teststack* ()) (let Result (shen.reduce_help V236) (cons (cons : (cons shen.tests (reverse (value shen.*teststack*)))) (cons Result ())))))

(defun shen.reduce_help (V238) (cond ((and (cons? V238) (and (cons? (hd V238)) (and (= /. (hd (hd V238))) (and (cons? (tl (hd V238))) (and (cons? (hd (tl (hd V238)))) (and (= cons (hd (hd (tl (hd V238))))) (and (cons? (tl (hd (tl (hd V238))))) (and (cons? (tl (tl (hd (tl (hd V238)))))) (and (= () (tl (tl (tl (hd (tl (hd V238))))))) (and (cons? (tl (tl (hd V238)))) (and (= () (tl (tl (tl (hd V238))))) (and (cons? (tl V238)) (= () (tl (tl V238))))))))))))))) (do (shen.add_test (cons cons? (tl V238))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V238))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V238)))))) (cons (shen.ebr (hd (tl V238)) (hd (tl (hd V238))) (hd (tl (tl (hd V238))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hd (tl V238)) ())) (cons (cons tl (tl V238)) ())) (shen.reduce_help Application))))) ((and (cons? V238) (and (cons? (hd V238)) (and (= /. (hd (hd V238))) (and (cons? (tl (hd V238))) (and (cons? (hd (tl (hd V238)))) (and (= @p (hd (hd (tl (hd V238))))) (and (cons? (tl (hd (tl (hd V238))))) (and (cons? (tl (tl (hd (tl (hd V238)))))) (and (= () (tl (tl (tl (hd (tl (hd V238))))))) (and (cons? (tl (tl (hd V238)))) (and (= () (tl (tl (tl (hd V238))))) (and (cons? (tl V238)) (= () (tl (tl V238))))))))))))))) (do (shen.add_test (cons tuple? (tl V238))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V238))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V238)))))) (cons (shen.ebr (hd (tl V238)) (hd (tl (hd V238))) (hd (tl (tl (hd V238))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons fst (tl V238)) ())) (cons (cons snd (tl V238)) ())) (shen.reduce_help Application))))) ((and (cons? V238) (and (cons? (hd V238)) (and (= /. (hd (hd V238))) (and (cons? (tl (hd V238))) (and (cons? (hd (tl (hd V238)))) (and (= @v (hd (hd (tl (hd V238))))) (and (cons? (tl (hd (tl (hd V238))))) (and (cons? (tl (tl (hd (tl (hd V238)))))) (and (= () (tl (tl (tl (hd (tl (hd V238))))))) (and (cons? (tl (tl (hd V238)))) (and (= () (tl (tl (tl (hd V238))))) (and (cons? (tl V238)) (= () (tl (tl V238))))))))))))))) (do (shen.add_test (cons shen.+vector? (tl V238))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V238))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V238)))))) (cons (shen.ebr (hd (tl V238)) (hd (tl (hd V238))) (hd (tl (tl (hd V238))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hdv (tl V238)) ())) (cons (cons tlv (tl V238)) ())) (shen.reduce_help Application))))) ((and (cons? V238) (and (cons? (hd V238)) (and (= /. (hd (hd V238))) (and (cons? (tl (hd V238))) (and (cons? (hd (tl (hd V238)))) (and (= @s (hd (hd (tl (hd V238))))) (and (cons? (tl (hd (tl (hd V238))))) (and (cons? (tl (tl (hd (tl (hd V238)))))) (and (= () (tl (tl (tl (hd (tl (hd V238))))))) (and (cons? (tl (tl (hd V238)))) (and (= () (tl (tl (tl (hd V238))))) (and (cons? (tl V238)) (= () (tl (tl V238))))))))))))))) (do (shen.add_test (cons shen.+string? (tl V238))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V238))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V238)))))) (cons (shen.ebr (hd (tl V238)) (hd (tl (hd V238))) (hd (tl (tl (hd V238))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons pos (cons (hd (tl V238)) (cons 0 ()))) ())) (cons (cons tlstr (tl V238)) ())) (shen.reduce_help Application))))) ((and (cons? V238) (and (cons? (hd V238)) (and (= /. (hd (hd V238))) (and (cons? (tl (hd V238))) (and (cons? (tl (tl (hd V238)))) (and (= () (tl (tl (tl (hd V238))))) (and (cons? (tl V238)) (and (= () (tl (tl V238))) (not (variable? (hd (tl (hd V238))))))))))))) (do (shen.add_test (cons = (cons (hd (tl (hd V238))) (tl V238)))) (shen.reduce_help (hd (tl (tl (hd V238))))))) ((and (cons? V238) (and (cons? (hd V238)) (and (= /. (hd (hd V238))) (and (cons? (tl (hd V238))) (and (cons? (tl (tl (hd V238)))) (and (= () (tl (tl (tl (hd V238))))) (and (cons? (tl V238)) (= () (tl (tl V238)))))))))) (shen.reduce_help (shen.ebr (hd (tl V238)) (hd (tl (hd V238))) (hd (tl (tl (hd V238))))))) ((and (cons? V238) (and (= where (hd V238)) (and (cons? (tl V238)) (and (cons? (tl (tl V238))) (= () (tl (tl (tl V238)))))))) (do (shen.add_test (hd (tl V238))) (shen.reduce_help (hd (tl (tl V238)))))) ((and (cons? V238) (and (cons? (tl V238)) (= () (tl (tl V238))))) (let Z (shen.reduce_help (hd V238)) (if (= (hd V238) Z) V238 (shen.reduce_help (cons Z (tl V238)))))) (true V238)))

(defun shen.+string? (V240) (cond ((= "" V240) false) (true (string? V240))))

(defun shen.+vector? (V242) (and (absvector? V242) (> (<-address V242 0) 0)))

(defun shen.ebr (V256 V257 V258) (cond ((= V258 V257) V256) ((and (cons? V258) (and (= /. (hd V258)) (and (cons? (tl V258)) (and (cons? (tl (tl V258))) (and (= () (tl (tl (tl V258)))) (> (occurrences V257 (hd (tl V258))) 0)))))) V258) ((and (cons? V258) (and (= lambda (hd V258)) (and (cons? (tl V258)) (and (cons? (tl (tl V258))) (and (= () (tl (tl (tl V258)))) (> (occurrences V257 (hd (tl V258))) 0)))))) V258) ((and (cons? V258) (and (= let (hd V258)) (and (cons? (tl V258)) (and (cons? (tl (tl V258))) (and (cons? (tl (tl (tl V258)))) (and (= () (tl (tl (tl (tl V258))))) (= (hd (tl V258)) V257))))))) (cons let (cons (hd (tl V258)) (cons (shen.ebr V256 (hd (tl V258)) (hd (tl (tl V258)))) (tl (tl (tl V258))))))) ((cons? V258) (cons (shen.ebr V256 V257 (hd V258)) (shen.ebr V256 V257 (tl V258)))) (true V258)))

(defun shen.add_test (V260) (set shen.*teststack* (cons V260 (value shen.*teststack*))))

(defun shen.cond-expression (V264 V265 V266) (let Err (shen.err-condition V264) (let Cases (shen.case-form V266 Err) (let EncodeChoices (shen.encode-choices Cases V264) (shen.cond-form EncodeChoices)))))

(defun shen.cond-form (V270) (cond ((and (cons? V270) (and (cons? (hd V270)) (and (= true (hd (hd V270))) (and (cons? (tl (hd V270))) (= () (tl (tl (hd V270)))))))) (hd (tl (hd V270)))) (true (cons cond V270))))

(defun shen.encode-choices (V275 V276) (cond ((= () V275) ()) ((and (cons? V275) (and (cons? (hd V275)) (and (= true (hd (hd V275))) (and (cons? (tl (hd V275))) (and (cons? (hd (tl (hd V275)))) (and (= shen.choicepoint! (hd (hd (tl (hd V275))))) (and (cons? (tl (hd (tl (hd V275))))) (and (= () (tl (tl (hd (tl (hd V275)))))) (and (= () (tl (tl (hd V275)))) (= () (tl V275))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V275))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (if (value shen.*installing-kl*) (cons shen.sys-error (cons V276 ())) (cons shen.f_error (cons V276 ()))) (cons Result ())))) ())))) ())) ())) ((and (cons? V275) (and (cons? (hd V275)) (and (= true (hd (hd V275))) (and (cons? (tl (hd V275))) (and (cons? (hd (tl (hd V275)))) (and (= shen.choicepoint! (hd (hd (tl (hd V275))))) (and (cons? (tl (hd (tl (hd V275))))) (and (= () (tl (tl (hd (tl (hd V275)))))) (= () (tl (tl (hd V275)))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V275))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (shen.cond-form (shen.encode-choices (tl V275) V276)) (cons Result ())))) ())))) ())) ())) ((and (cons? V275) (and (cons? (hd V275)) (and (cons? (tl (hd V275))) (and (cons? (hd (tl (hd V275)))) (and (= shen.choicepoint! (hd (hd (tl (hd V275))))) (and (cons? (tl (hd (tl (hd V275))))) (and (= () (tl (tl (hd (tl (hd V275)))))) (= () (tl (tl (hd V275))))))))))) (cons (cons true (cons (cons let (cons Freeze (cons (cons freeze (cons (shen.cond-form (shen.encode-choices (tl V275) V276)) ())) (cons (cons if (cons (hd (hd V275)) (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V275))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (cons thaw (cons Freeze ())) (cons Result ())))) ())))) (cons (cons thaw (cons Freeze ())) ())))) ())))) ())) ())) ((and (cons? V275) (and (cons? (hd V275)) (and (cons? (tl (hd V275))) (= () (tl (tl (hd V275))))))) (cons (hd V275) (shen.encode-choices (tl V275) V276))) (true (shen.f_error shen.encode-choices))))

(defun shen.case-form (V283 V284) (cond ((= () V283) (cons V284 ())) ((and (cons? V283) (and (cons? (hd V283)) (and (cons? (hd (hd V283))) (and (= : (hd (hd (hd V283)))) (and (cons? (tl (hd (hd V283)))) (and (= shen.tests (hd (tl (hd (hd V283))))) (and (= () (tl (tl (hd (hd V283))))) (and (cons? (tl (hd V283))) (and (cons? (hd (tl (hd V283)))) (and (= shen.choicepoint! (hd (hd (tl (hd V283))))) (and (cons? (tl (hd (tl (hd V283))))) (and (= () (tl (tl (hd (tl (hd V283)))))) (= () (tl (tl (hd V283)))))))))))))))) (cons (cons true (tl (hd V283))) (shen.case-form (tl V283) V284))) ((and (cons? V283) (and (cons? (hd V283)) (and (cons? (hd (hd V283))) (and (= : (hd (hd (hd V283)))) (and (cons? (tl (hd (hd V283)))) (and (= shen.tests (hd (tl (hd (hd V283))))) (and (= () (tl (tl (hd (hd V283))))) (and (cons? (tl (hd V283))) (= () (tl (tl (hd V283)))))))))))) (cons (cons true (tl (hd V283))) ())) ((and (cons? V283) (and (cons? (hd V283)) (and (cons? (hd (hd V283))) (and (= : (hd (hd (hd V283)))) (and (cons? (tl (hd (hd V283)))) (and (= shen.tests (hd (tl (hd (hd V283))))) (and (cons? (tl (hd V283))) (= () (tl (tl (hd V283))))))))))) (cons (cons (shen.embed-and (tl (tl (hd (hd V283))))) (tl (hd V283))) (shen.case-form (tl V283) V284))) (true (shen.f_error shen.case-form))))

(defun shen.embed-and (V286) (cond ((and (cons? V286) (= () (tl V286))) (hd V286)) ((cons? V286) (cons and (cons (hd V286) (cons (shen.embed-and (tl V286)) ())))) (true (shen.f_error shen.embed-and))))

(defun shen.err-condition (V288) (cons true (cons (cons shen.f_error (cons V288 ())) ())))

(defun shen.sys-error (V290) (simple-error (cn "system function " (shen.app V290 ": unexpected argument
" shen.a))))



